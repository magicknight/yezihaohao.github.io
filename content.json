{"meta":{"title":"前端博客","subtitle":"前端分享","description":"学习总结 思考感悟","author":"chenghao","url":"https://yezihaohao.github.io"},"pages":[{"title":"Hello World","date":"un44fin44","updated":"un44fin44","path":"hello-world.html","permalink":"https://yezihaohao.github.io/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"about","date":"un44fin44","updated":"un44fin44","path":"about/index.html","permalink":"https://yezihaohao.github.io/about/index.html","excerpt":"","text":"关于测试呵呵我只是想安静地写前端"},{"title":"categories","date":"un44fin44","updated":"un44fin44","path":"categories/index.html","permalink":"https://yezihaohao.github.io/categories/index.html","excerpt":"","text":""},{"title":"imgs","date":"un66fin66","updated":"un66fin66","path":"imgs/index.html","permalink":"https://yezihaohao.github.io/imgs/index.html","excerpt":"","text":""},{"title":"tags","date":"un44fin44","updated":"un44fin44","path":"tags/index.html","permalink":"https://yezihaohao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React+AntD后台管理系统解决方案--终极版","slug":"React-AntD后台管理系统解决方案-终极版","date":"un22fin22","updated":"un22fin22","path":"2017/05/09/React-AntD后台管理系统解决方案-终极版/","link":"","permalink":"https://yezihaohao.github.io/2017/05/09/React-AntD后台管理系统解决方案-终极版/","excerpt":"前言 网上react后台管理开源免费的完整版项目比较少，所以利用空余时间集成了一个版本出来，已放到GitHub 启动和打包的时间都稍长，请耐心等待两分钟 GitHub地址 预览地址(还没做响应式，不建议手机预览😕) 依赖模块项目是用create-react-app创建的，主要还是列出新加的功能依赖包 点击名称可跳转相关网站😄😄 react@15.5.0 react-router@3.0.2(react路由,4.x的差异还是比较大，暂时还是3.x的版本) antd@2.9.3(蚂蚁金服开源的react ui组件框架) axios@0.16.1(http请求模块，可用于前端任何场景，很强大👍) echarts-for-react@1.2.0(可视化图表，别人基于react对echarts的封装，足够用了) recharts@0.22.3(另一个基于react封装的图表，个人觉得是没有echarts好用) nprogress@0.2.0(顶部加载条，蛮好用👍) react-draft-wysiwyg@1.9.6(别人基于react的富文本封装，如果找到其他更好的可以替换) react-draggable@2.2.4(拖拽模块，找了个简单版的) screenfull@3.2.0(全屏插件) photoswipe@4.1.2(图片弹层查看插件，不依赖jQuery，还是蛮好用👍) animate.css@3.5.1(css动画库) 其他小细节省略 功能模块备注：项目只引入了ant-design的部分组件，其他的组件antd官网有源码，可以直接复制到项目中使用，后续有时间补上全部组件。项目使用了antd的自定义主题功能–&gt;黑色，若想替换其他颜色，具体操作请查看antd官网","text":"前言 网上react后台管理开源免费的完整版项目比较少，所以利用空余时间集成了一个版本出来，已放到GitHub 启动和打包的时间都稍长，请耐心等待两分钟 GitHub地址 预览地址(还没做响应式，不建议手机预览😕) 依赖模块项目是用create-react-app创建的，主要还是列出新加的功能依赖包 点击名称可跳转相关网站😄😄 react@15.5.0 react-router@3.0.2(react路由,4.x的差异还是比较大，暂时还是3.x的版本) antd@2.9.3(蚂蚁金服开源的react ui组件框架) axios@0.16.1(http请求模块，可用于前端任何场景，很强大👍) echarts-for-react@1.2.0(可视化图表，别人基于react对echarts的封装，足够用了) recharts@0.22.3(另一个基于react封装的图表，个人觉得是没有echarts好用) nprogress@0.2.0(顶部加载条，蛮好用👍) react-draft-wysiwyg@1.9.6(别人基于react的富文本封装，如果找到其他更好的可以替换) react-draggable@2.2.4(拖拽模块，找了个简单版的) screenfull@3.2.0(全屏插件) photoswipe@4.1.2(图片弹层查看插件，不依赖jQuery，还是蛮好用👍) animate.css@3.5.1(css动画库) 其他小细节省略 功能模块备注：项目只引入了ant-design的部分组件，其他的组件antd官网有源码，可以直接复制到项目中使用，后续有时间补上全部组件。项目使用了antd的自定义主题功能–&gt;黑色，若想替换其他颜色，具体操作请查看antd官网 首页 完整布局 换肤(全局功能，暂时只实现了顶部导航的换肤，后续加上其他模块) 导航菜单 顶部导航(菜单伸缩，全屏功能) 左边菜单(增加滚动条以及适配路由的active操作) UI模块 按钮(antd组件) 图标(antd组件并增加彩色表情符) 加载中(antd组件并增加顶部加载条) 通知提醒框(antd组件) 标签页(antd组件) 轮播图(ant动效组件) 富文本 拖拽 画廊 动画 基础动画(animate.css所有动画) 动画案例 表格 基础表格(antd组件) 高级表格(antd组件) 异步表格(数据来自掘金酱的接口) 表单 基础表单(antd组件) 图表 echarts图表 recharts图表 页面 登录页面(包括GitHub第三方登录) 404页面 功能截图首页 按钮图标等 轮播图 富文本 拖拽 画廊 动画 表格 表单 图表 页面 代码目录123456789101112131415161718192021222324252627282930313233343536+-- build/ ---打包的文件目录+-- config/ ---npm run eject 后的配置文件目录+-- node_modules/ ---npm下载文件目录+-- public/ | --- index.html ---首页入口html文件| --- npm.json ---echarts测试数据| --- weibo.json ---echarts测试数据+-- src/ ---核心代码目录| +-- axios ---http请求存放目录| | --- index.js| +-- components ---各式各样的组件存放目录| | +-- animation ---动画组件| | | --- ... | | +-- charts ---图表组件| | | --- ... | | +-- dashboard ---首页组件| | | --- ... | | +-- forms ---表单组件| | | --- ... | | +-- pages ---页面组件| | | --- ... | | +-- tables ---表格组件| | | --- ... | | +-- ui ---ui组件| | | --- ... | | --- BreadcrumbCustom.jsx ---面包屑组件| | --- HeaderCustom.jsx ---顶部导航组件| | --- Page.jsx ---页面容器| | --- SiderCustom.jsx ---左边菜单组件| +-- style ---项目的样式存放目录，主要采用less编写| +-- utils ---工具文件存放目录| --- App.js ---组件入口文件| --- index.js ---项目的整体js入口文件，包括路由配置等--- .env ---启动项目自定义端口配置文件--- .eslintrc ---自定义eslint配置文件，包括增加的react jsx语法限制--- package.json 安装运行1.下载或克隆项目源码2.npm安装相关包文件(国内建议增加淘宝镜像源，不然很慢，你懂的😁)1npm i 3.启动项目1npm start 4.打包项目1npm run build 结尾该项目会不定时更新，后续时间会添加更多的模块 若有问题，可加QQ群264591039与我交流 如果对你有帮助，给个star哟~~❤️❤️❤️❤️","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://yezihaohao.github.io/tags/React/"}]},{"title":"React项目笔记之create-react-app自定义ESLint配置文件","slug":"React项目笔记-create-react-app自定义ESLint配置文件","date":"un00fin00","updated":"un11fin11","path":"2017/03/26/React项目笔记-create-react-app自定义ESLint配置文件/","link":"","permalink":"https://yezihaohao.github.io/2017/03/26/React项目笔记-create-react-app自定义ESLint配置文件/","excerpt":"前言 了解eslint基础用法，若想更进一步了解其，请查阅官网以及相关资料(中文网) 若有问题请指出或加群264591039与我讨论。 初始化项目使用create-react-app 创建项目（此过程不做详解），然后运行npm run eject使其暴露webpack等配置文件 自定义eslint上述步骤并没有暴露react脚手架封装的eslint操作，为了使得项目统一规范化，添加jsx-eslint操作是非常不错的选择（关于js其他的eslint操作，请参见官网，本文主要针对jsx限制规范配置）。 在项目根目录下添加.eslintrc文件","text":"前言 了解eslint基础用法，若想更进一步了解其，请查阅官网以及相关资料(中文网) 若有问题请指出或加群264591039与我讨论。 初始化项目使用create-react-app 创建项目（此过程不做详解），然后运行npm run eject使其暴露webpack等配置文件 自定义eslint上述步骤并没有暴露react脚手架封装的eslint操作，为了使得项目统一规范化，添加jsx-eslint操作是非常不错的选择（关于js其他的eslint操作，请参见官网，本文主要针对jsx限制规范配置）。 在项目根目录下添加.eslintrc文件 在根目录找到config文件夹，并找到文件夹下的webpack.config.dev.js文件 webpack.config.dev.js文件添加如下代码：1234567891011enforce: 'pre',use: [&#123; // @remove-on-eject-begin // Point ESLint to our predefined config. options: &#123; //configFile: path.join(__dirname, '../.eslintrc'), useEslintrc: true &#125;, // @remove-on-eject-end loader: 'eslint-loader'&#125;], 运行npm start,此时，你编写的jsx文件都是经过.eslintrc的配置限制 .eslintrc文件基本规范配置ps: 配置的value对应的值： 0 : off 1 : warning 2 : error不满足以下的规范设置的，编译代码时将有黄色提示具体配置规则可参见Github123456789101112131415&#123; \"extends\": \"react-app\", \"rules\": &#123; \"no-multi-spaces\": 1, \"react/jsx-space-before-closing\": 1, // 总是在自动关闭的标签前加一个空格，正常情况下也不需要换行 \"jsx-quotes\": 1, \"react/jsx-closing-bracket-location\": 1, // 遵循JSX语法缩进/格式 \"react/jsx-boolean-value\": 1, // 如果属性值为 true, 可以直接省略 \"react/no-string-refs\": 1, // 总是在Refs里使用回调函数 \"react/self-closing-comp\": 1, // 对于没有子元素的标签来说总是自己关闭标签 \"react/jsx-no-bind\": 1, // 当在 render() 里使用事件处理方法时，提前在构造函数里把 this 绑定上去 \"react/sort-comp\": 1, // 按照具体规范的React.createClass 的生命周期函数书写代码 \"react/jsx-pascal-case\": 1 // React模块名使用帕斯卡命名，实例使用骆驼式命名 &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://yezihaohao.github.io/tags/react/"},{"name":"eslint","slug":"eslint","permalink":"https://yezihaohao.github.io/tags/eslint/"}]},{"title":"Javascript项目笔记","slug":"Javascript项目笔记","date":"un11fin11","updated":"un33fin33","path":"2017/03/13/Javascript项目笔记/","link":"","permalink":"https://yezihaohao.github.io/2017/03/13/Javascript项目笔记/","excerpt":"针对项目中常用的javascript api等，进行一个汇总~文档持续更新中。。。 前提：有些功能可能浏览器还不支持，需要用babel进行转换，具体的babel环境搭建，请自行Baidu或google。 很多框架的脚手架生成的helloworld项目是已经搭好的环境，比如react或者vue，所以使用脚手架的童鞋大可放心使用。 若有问题可加群264591039与我讨论。 扩展运算符：三个点 …合并数组1234let arr1 = [1, 2], arr2 = [3, 4];arr1.push(...arr2); // 把arr2合并到arr1的尾部, arr1改变arr1.unshift(...arr2); // 把arr2合并到arr1的顶部, arr1改变[...arr1, ...arr2]; // 生成一个由arr1和arr2组成的新数组，原数组不变 复制对象","text":"针对项目中常用的javascript api等，进行一个汇总~文档持续更新中。。。 前提：有些功能可能浏览器还不支持，需要用babel进行转换，具体的babel环境搭建，请自行Baidu或google。 很多框架的脚手架生成的helloworld项目是已经搭好的环境，比如react或者vue，所以使用脚手架的童鞋大可放心使用。 若有问题可加群264591039与我讨论。 扩展运算符：三个点 …合并数组1234let arr1 = [1, 2], arr2 = [3, 4];arr1.push(...arr2); // 把arr2合并到arr1的尾部, arr1改变arr1.unshift(...arr2); // 把arr2合并到arr1的顶部, arr1改变[...arr1, ...arr2]; // 生成一个由arr1和arr2组成的新数组，原数组不变 复制对象 1234567let obj = &#123;a: 1&#125;;&#123;...obj, b: 2&#125;; // 返回一个新的对象，&#123;a: 1, b: 2&#125;, obj对象不变// 等价于下面的用法Object.assign(&#123;&#125;, obj, &#123;b: 2&#125;); // 返回一个新的对象，&#123;a: 1, b: 2&#125;, obj对象不变// 另外Object.assign 还有一个用法Object.assign(obj, &#123;b: 2&#125;); // 返回obj对象并且新增加了b属性：&#123;a: 1, b: 2&#125; obj对象改变// 由于使用的chrome浏览器还不支持第一种用法，只能演示Object.assign。项目中使用babel转换","categories":[],"tags":[]},{"title":"Socket.io+Notification实现浏览器消息推送","slug":"Socket-io-Notification实现浏览器消息推送","date":"un11fin11","updated":"un22fin22","path":"2017/02/20/Socket-io-Notification实现浏览器消息推送/","link":"","permalink":"https://yezihaohao.github.io/2017/02/20/Socket-io-Notification实现浏览器消息推送/","excerpt":"前言 socket.io: 包含对websocket的封装，可实现服务端和客户端之前的通信。详情见官网 (虽然是英文文档，但还是通俗易懂)。 Notification: Html5新特性，用于浏览器的桌面通知，只有部分浏览器支持。 通过nodejs+Socket.io+Notification实现服务端往浏览器客户端发送自定义消息。 若有问题可加群264591039与我讨论。 转载请注明出处！ 开发前提本地安装nodejs以及npm对nodejs以及express框架有一定了解。（本篇将和官方文档一样，采用express 4.10.2） 环境搭建 新建一个文件夹notification（以下操作都在该文件夹的根目录进行） npm初始化package.json文件 npm init 安装express(指定版本4.10.2，没有试过其他版本，感兴趣可以试下) npm install --save express@4.10.2 安装socket.io(本人安装的版本是1.7.3) npm install --save socket.io 编写代码构建通信环境在根目录下新建一个index.html（注：index页面的样式来自socket.io的官方示例）12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Socket.IO Notification&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font: 13px Helvetica, Arial; &#125; form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125; form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125; #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125; #messages li &#123; padding: 5px 10px; &#125; #messages li:nth-child(odd) &#123; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;messages&quot;&gt;&lt;/ul&gt; &lt;form action=&quot;&quot;&gt; &lt;input id=&quot;m&quot; autocomplete=&quot;off&quot; /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 新建一个index.js文件，并在js文件中构建相应的对象和变量，创建监听端口为8080 的服务器，以及添加映射到index.html的路由。","text":"前言 socket.io: 包含对websocket的封装，可实现服务端和客户端之前的通信。详情见官网 (虽然是英文文档，但还是通俗易懂)。 Notification: Html5新特性，用于浏览器的桌面通知，只有部分浏览器支持。 通过nodejs+Socket.io+Notification实现服务端往浏览器客户端发送自定义消息。 若有问题可加群264591039与我讨论。 转载请注明出处！ 开发前提本地安装nodejs以及npm对nodejs以及express框架有一定了解。（本篇将和官方文档一样，采用express 4.10.2） 环境搭建 新建一个文件夹notification（以下操作都在该文件夹的根目录进行） npm初始化package.json文件 npm init 安装express(指定版本4.10.2，没有试过其他版本，感兴趣可以试下) npm install --save express@4.10.2 安装socket.io(本人安装的版本是1.7.3) npm install --save socket.io 编写代码构建通信环境在根目录下新建一个index.html（注：index页面的样式来自socket.io的官方示例）12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Socket.IO Notification&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font: 13px Helvetica, Arial; &#125; form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125; form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125; #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125; #messages li &#123; padding: 5px 10px; &#125; #messages li:nth-child(odd) &#123; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;messages&quot;&gt;&lt;/ul&gt; &lt;form action=&quot;&quot;&gt; &lt;input id=&quot;m&quot; autocomplete=&quot;off&quot; /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 新建一个index.js文件，并在js文件中构建相应的对象和变量，创建监听端口为8080 的服务器，以及添加映射到index.html的路由。12345678910111213let express = require('express'), app = express(), http = require('http').Server(app), io = require('socket.io')(http);app.use(express.static(__dirname + '/public'));app.get('/', function(req, res)&#123; res.sendfile('index.html');&#125;);http.listen(8080, function()&#123; console.log('listening on port 8080');&#125;); 运行 node index.js 用浏览器打开http://localhost:8080 成功的话即可看到index.html页面的内容。在index.js的监听端口代码上方添加socket.io的监听事件，监听用户连接的connection。123io.on('connection', function(socket)&#123; console.log('a user connected');&#125;); 创建监听Event事件:notification，并用emit向客户端推送消息1234567io.on('connection', function(socket)&#123; console.log('a user connected'); socket.on('notification', function(msg)&#123; console.log(msg); io.emit('notification', msg); &#125;);&#125;); 在index.html页面中的上方引入socket.io文件，并用emit向服务器提交数据以及监听事件notification，接收服务器推送的消息注意，引入socket.io的方式在运行node index.js之后才有效果，直接打开index.html是找不到这个文件的12345678910111213 &lt;script type=\"text/javascript\" src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt;let socket = io();$('form').submit(function()&#123; socket.emit('notification', $('#m').val()); $('#m').val(''); return false;&#125;);socket.on('notification', function(msg)&#123; console.log(msg);&#125;); &lt;/script&gt; 浏览器打开http://localhost:8080 后，在input框中输入，点击发送，在nodejs运行的控制台可以看到如下信息：1234a user connected //以下数据是输入框输入的数据hello test测试 实现自定义消息推送完整代码：12345678910111213141516171819202122232425 &lt;script&gt;let socket = io();$('form').submit(function()&#123; socket.emit('notification', $('#m').val()); $('#m').val(''); return false;&#125;);socket.on('notification', function(msg)&#123; notice(msg); //若允许通知，待输入消息后监听变化就会调用通知方法&#125;); Notification.requestPermission(function(permission) &#123;&#125;); //询问浏览器是否允许通知 function notice(msg) &#123; let _notification = new Notification(`消息通知`,&#123; body:`$&#123;msg&#125;`, icon:'http://localhost:8080/23539868.jpg' &#125;); setTimeout(function()&#123; _notification.close(); //设置5秒后自动关闭通知框 &#125;,5000); &#125; &lt;/script&gt; 运行截图完整示例代码见GitHub","categories":[{"name":"消息推送","slug":"消息推送","permalink":"https://yezihaohao.github.io/categories/消息推送/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://yezihaohao.github.io/tags/Nodejs/"},{"name":"Socket.io","slug":"Socket-io","permalink":"https://yezihaohao.github.io/tags/Socket-io/"}]},{"title":"Vuejs2.X组件化-阿里的G2图表组件","slug":"Vuejs2-X组件化-阿里的G2图表组件","date":"un22fin22","updated":"un22fin22","path":"2017/02/14/Vuejs2-X组件化-阿里的G2图表组件/","link":"","permalink":"https://yezihaohao.github.io/2017/02/14/Vuejs2-X组件化-阿里的G2图表组件/","excerpt":"前言 vue 的组件化开发是一个非常不错的机制.’一处开发,多处引用’，不仅降低的维护成本，提高了开发效率，而且单独的组件有单独的视图和交互数据逻辑，使得系统层次更加分明。若有问题可加群264591039与我讨论~转载文章请标明出处！ 开发场景数据可视化是我们互联网常见的功能，所以难免我们会在项目中插入图表等，找到一个还算可以的图形插件，阿里的G2图形库，详情请参见G2官网。接下来就开始我们的Vue G2组件化之旅。 脚手架搭建helloworld先用脚手架工具 vue-cli搭建一个vue的helloworld项目(Vue的相关教程请看Vue官网)，按照readme文档正常运行该项目。 安装G2插件在package.json的目录下用npm包管理工具安装G2插件库1npm install --save-dev g2 我用到的版本是2.2.1，现在最新的好像是2.2.2，应该也没什么问题，不过我没测试过 新建G2Line.vue单文件组件在components目录下新建G2Line.vue文件（当前是以线形图为例的组件）。在template标签中新增标签1234&lt;template&gt; &lt;!--此处的id用变量，方便同一页面引用多次相同的组件--&gt; &lt;div :id=\"id\"&gt;&lt;/div&gt;&lt;/template&gt;","text":"前言 vue 的组件化开发是一个非常不错的机制.’一处开发,多处引用’，不仅降低的维护成本，提高了开发效率，而且单独的组件有单独的视图和交互数据逻辑，使得系统层次更加分明。若有问题可加群264591039与我讨论~转载文章请标明出处！ 开发场景数据可视化是我们互联网常见的功能，所以难免我们会在项目中插入图表等，找到一个还算可以的图形插件，阿里的G2图形库，详情请参见G2官网。接下来就开始我们的Vue G2组件化之旅。 脚手架搭建helloworld先用脚手架工具 vue-cli搭建一个vue的helloworld项目(Vue的相关教程请看Vue官网)，按照readme文档正常运行该项目。 安装G2插件在package.json的目录下用npm包管理工具安装G2插件库1npm install --save-dev g2 我用到的版本是2.2.1，现在最新的好像是2.2.2，应该也没什么问题，不过我没测试过 新建G2Line.vue单文件组件在components目录下新建G2Line.vue文件（当前是以线形图为例的组件）。在template标签中新增标签1234&lt;template&gt; &lt;!--此处的id用变量，方便同一页面引用多次相同的组件--&gt; &lt;div :id=\"id\"&gt;&lt;/div&gt;&lt;/template&gt; 在script标签中引入G2并开始先关操作代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import G2 from 'g2'; export default &#123; data () &#123; return &#123; chart: null &#125;; &#125;, props: &#123; charData: &#123; type: Array, default: function () &#123; return &#123; data: [&#123;'mzkId': 112, 'strftime': \"2017-01-11\", 'value': 9275501&#125;, // 测试数据，根据自己需求自己设置数据 &#123;'mzkId': 112, 'strftime': \"2017-01-12\", 'value': 9281904&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-13\", 'value': 9290777&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-14\", 'value': 9297913&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-15\", 'value': 9306918&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-16\", 'value': 9315641&#125;] &#125;; &#125; &#125;, id: String &#125;, mounted: function () &#123;// this.drawChart(); // 第一步想到的是创建的时候更新图表，但是这个不适用于异步请求接口获取相关数据，所以采用下面的监听的方式 &#125;, beforeUpdate: function () &#123;// this.drawChart(); &#125;, watch: &#123; charData: function (val, oldVal) &#123; // 监听charData，当放生变化时，触发这个回调函数绘制图表 console.log('new: %s, old: %s', val, oldVal); this.drawChart(val); &#125; &#125;, methods: &#123; drawChart: function (datas) &#123; // 如果图形存在则删除再创建，这个地方感觉稍微有点坑 // 具体的G2 api函数说明请看上面提供的官网地址，此处不再逐一说明 this.chart &amp;&amp; this.chart.destroy(); let data = datas; this.chart = new G2.Chart(&#123; id: this.id, width: 1000, height: 250 &#125;); this.chart.source(data, &#123; strftime: &#123; alias: '日期', type: 'cat', range: [0, 1] &#125;, value: &#123; alias: '数量值(人)' &#125; &#125;); this.chart.line().position('strftime*value').size(2); this.chart.point().position('strftime*value').color('#757373') .shape('circle') .label('value', &#123;offset: 20, label: &#123;fill: '#000'&#125;&#125;); this.chart.animate(false); this.chart.render(); &#125; &#125; &#125; App.vue引入组件并渲染图表在app.vue中引入上一步新建的G2Line.vue组件，并加载到当前vue实例中1234567891011121314151617&lt;script&gt; import G2Line from './components/G2Line.vue'; export default &#123; components: &#123; G2Line &#125;, data () &#123; return &#123; serverData: [] &#125; &#125;, methods: &#123; // 此处省略从服务器获取数据并且赋值给this.serverData // 推荐使用axios请求接口 &#125; &#125;&lt;/script&gt; 获取服务端数据之后，在template中创建组件标签，并将serverData发送给子组件G2Line12&lt;!--同步设置id传送给子组件--&gt;&lt;g2-line :charData=\"serverData\" :id=\"'c1'\" id=\"c1\"&gt;&lt;/g2-line&gt; 刷新界面，成功看到页面图表的渲染","categories":[],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"https://yezihaohao.github.io/tags/Vuejs/"}]},{"title":"Nodejs爬虫--抓取豆瓣电影网页数据（下）","slug":"Nodejs爬虫-抓取豆瓣电影网页数据（下）","date":"un66fin66","updated":"un66fin66","path":"2017/02/11/Nodejs爬虫-抓取豆瓣电影网页数据（下）/","link":"","permalink":"https://yezihaohao.github.io/2017/02/11/Nodejs爬虫-抓取豆瓣电影网页数据（下）/","excerpt":"接着上篇 Nodejs爬虫–抓取豆瓣电影网页数据（上） 本篇主要描述将上次抓取的数据存入mongodb数据库 前提：百度或谷歌mongodb的安装教程，安装本地并成功运行 推荐一款mongodb数据库可视化管理工具：Robomongo。可以加群264591039获取安装包或自行寻找资源 首先用npm安装第三方数据库操作包：mongoose.关于mongoose详情请查看官方文档1npm install --save-dev mongoose 引入mongoose包开始对mongodb进行管理当前目录下新建一个mongo.js文件方便管理，在该文件中引入相关包：12let mongoose = require('mongoose'), assert = require('assert');","text":"接着上篇 Nodejs爬虫–抓取豆瓣电影网页数据（上） 本篇主要描述将上次抓取的数据存入mongodb数据库 前提：百度或谷歌mongodb的安装教程，安装本地并成功运行 推荐一款mongodb数据库可视化管理工具：Robomongo。可以加群264591039获取安装包或自行寻找资源 首先用npm安装第三方数据库操作包：mongoose.关于mongoose详情请查看官方文档1npm install --save-dev mongoose 引入mongoose包开始对mongodb进行管理当前目录下新建一个mongo.js文件方便管理，在该文件中引入相关包：12let mongoose = require('mongoose'), assert = require('assert'); 获取表构造器Schema并映射mongodb相应的collection12345678910111213let Schema = mongoose.Schema;let filmSchema = new Schema(&#123; //自定义相应的表数据字段 title: String, type: String, directories: String, scriptwriter: String, actors: String &#125;);//映射collection并生成model对象用于管理数据表的增删改查//默认是映射到名为films的collection//若自定义表明则：let filmSchema = new Schema(&#123;..&#125;, &#123; collection: 'data' &#125;); 'data'即为自定义名称let Film = mongoose.model('Film', filmSchema); 连接mongodb数据库并exports Film对象123456789let db = mongoose.connect('mongodb://127.0.0.1:27017/spider');db.connection.on('error', (err) =&gt; &#123; console.log(`数据库连接失败：$&#123;err&#125;`);&#125;);db.connection.on('open', () =&gt; &#123; console.log('数据库连接成功');&#125;);module.exports = &#123;Film: Film&#125;; 在spider.js中引入Film对象并添加入库操作代码123456789101112131415161718let mongo = require('./mongo');//在请求网页的end函数中添加入库操作xxxx.end((err, res) =&gt; &#123; var $ = cheerio.load(res.text); //用cheerio获取整个页面DOM对象 var _data = &#123;title:'', type: '', directories: '', scriptwriter: '', actors: ''&#125;; _data.title = $('#content h1 span').text(); _data.directories = $('#info .attrs').eq(0).text(); _data.scriptwriter = $('#info .attrs').eq(1).text(); _data.actors = $('#info .attrs').eq(2).text(); $('span[property=\"v:genre\"]').each(function (index) &#123; _data.type += ($(this).text() + (index == $('span[property=\"v:genre\"]').length - 1 ? '' : '、')); &#125;); console.log(_data); mongo.Film.create(_data, (err, doc) =&gt; &#123; assert.equal(err, null); console.log(doc); &#125;);&#125;); 运行spider.js，并查看数据库中的数据12node spider.js//用上述提到的可视化工具查看数据库是否成功有数据入库","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yezihaohao.github.io/categories/爬虫/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yezihaohao.github.io/tags/Javascript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://yezihaohao.github.io/tags/Nodejs/"}]},{"title":"Javascript正则表达式整合","slug":"Javascript正则表达式整合","date":"un55fin55","updated":"un55fin55","path":"2017/02/10/Javascript正则表达式整合/","link":"","permalink":"https://yezihaohao.github.io/2017/02/10/Javascript正则表达式整合/","excerpt":"项目中常用正则表达式使用整合大全提取网页标签内容一.单个标签提取123let str = `&lt;a class=\"menu\"&gt;GitHub&lt;/a&gt;`;let content = str.match(/&lt;a class=\"menu\"&gt;([\\s\\S]+)&lt;\\/a&gt;/)[1];","text":"项目中常用正则表达式使用整合大全提取网页标签内容一.单个标签提取123let str = `&lt;a class=\"menu\"&gt;GitHub&lt;/a&gt;`;let content = str.match(/&lt;a class=\"menu\"&gt;([\\s\\S]+)&lt;\\/a&gt;/)[1]; 不定时更新中…","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://yezihaohao.github.io/categories/正则表达式/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yezihaohao.github.io/tags/Javascript/"}]},{"title":"Nodejs爬虫--抓取豆瓣电影网页数据（上）","slug":"Nodejs爬虫-抓取豆瓣电影网页数据（上）","date":"un44fin44","updated":"un66fin66","path":"2017/02/09/Nodejs爬虫-抓取豆瓣电影网页数据（上）/","link":"","permalink":"https://yezihaohao.github.io/2017/02/09/Nodejs爬虫-抓取豆瓣电影网页数据（上）/","excerpt":"之前写了一个nodejs的开源爬虫小项目，补上博客详细解析下代码。 PS：共有上下两篇，第一篇讲从网站上抓取数据，第二篇讲将抓取的数据存入mongodb数据库。 我们快速开始吧首先，安装nodejs，然后用npm工具初始化资源管理配置文件：package.json新建spider文件夹，在该文件夹下面初始化package.json1npm init 然后用npm安装相关库文件：1npm install --save-dev superagent cheerio eventproxy async 在文件夹下面新建spider.js, 在文件中引入需要用到的nodejs模块如下(具体用法请查询网上相关资料)：12345let superagent = require('superagent'), //nodejs里面一个非常方便的客户端代理请求模块，支持get,post,put,delete等 cheerio = require('cheerio'), //类似于jQuery的DOM操作模块，可以提取html中想要的信息 eventproxy = require('eventproxy'), //控制异步请求并发，可以监听请求，使得某些请求完毕之后在发送请求 assert = require('assert'), //异常抛出判断模块，assert.equal(err, null); 如果err不为null,则直接抛出异常 async = require('async'); //控制请求并发连接数","text":"之前写了一个nodejs的开源爬虫小项目，补上博客详细解析下代码。 PS：共有上下两篇，第一篇讲从网站上抓取数据，第二篇讲将抓取的数据存入mongodb数据库。 我们快速开始吧首先，安装nodejs，然后用npm工具初始化资源管理配置文件：package.json新建spider文件夹，在该文件夹下面初始化package.json1npm init 然后用npm安装相关库文件：1npm install --save-dev superagent cheerio eventproxy async 在文件夹下面新建spider.js, 在文件中引入需要用到的nodejs模块如下(具体用法请查询网上相关资料)：12345let superagent = require('superagent'), //nodejs里面一个非常方便的客户端代理请求模块，支持get,post,put,delete等 cheerio = require('cheerio'), //类似于jQuery的DOM操作模块，可以提取html中想要的信息 eventproxy = require('eventproxy'), //控制异步请求并发，可以监听请求，使得某些请求完毕之后在发送请求 assert = require('assert'), //异常抛出判断模块，assert.equal(err, null); 如果err不为null,则直接抛出异常 async = require('async'); //控制请求并发连接数 用superagent请求豆瓣的某个接口，并把所有的页面链接放到一个数组里面，用eventproxy控制监听该请求结束之后才开始请求相应的详情页面。12345678superagent.get(URL) .end((err, res) =&gt; &#123; let _pageUrls = []; res.body.forEach((val) =&gt; &#123; _pageUrls.push(val.url); &#125;); ep.emit('pageUrls', _pageUrls); //监听相关实例，完成之后告诉pageUrls &#125;) 监听事件完成之后，执行请求相应的豆瓣电影详情页面.并用async控制请求的并发量，可以降低请求的频率和速度123456789101112131415161718192021222324252627let ep = eventproxy.create('pageUrls', (pageUrls) =&gt; &#123; //创建一个监听实例 let _http = (url, callback) =&gt; &#123; let _delay = parseInt((Math.random() * 30000000) % 1000, 10); //随机延时请求 superagent.get(url) .end((err, res) =&gt; &#123; var $ = cheerio.load(res.text); //用cheerio获取整个页面DOM对象 var _data = &#123;title:'', type: '', directories: '', scriptwriter: '', actors: ''&#125;; _data.title = $('#content h1 span').text(); _data.directories = $('#info .attrs').eq(0).text(); _data.scriptwriter = $('#info .attrs').eq(1).text(); _data.actors = $('#info .attrs').eq(2).text(); $('span[property=\"v:genre\"]').each(function (index) &#123; _data.type += ($(this).text() + (index == $('span[property=\"v:genre\"]').length - 1 ? '' : '、')); &#125;); console.log(_data); &#125;); setTimeout(() =&gt; &#123; callback(null, url); &#125;, _delay); &#125;; async.mapLimit(pageUrls, 3, (url, callback) =&gt; &#123; //用async 的 mapLimit(arr, limit, iterator, callback) 接口控制请求并发量为3 _http(url, callback); &#125;, (err, res) =&gt; &#123; assert.equal(err, null); &#125;)&#125;); 本章节结束，未完待续…下期是怎么将抓取的数据存入mongodb数据库！","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yezihaohao.github.io/categories/爬虫/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yezihaohao.github.io/tags/Javascript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://yezihaohao.github.io/tags/Nodejs/"}]}]}