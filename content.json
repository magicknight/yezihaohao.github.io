{"meta":{"title":"前端博客","subtitle":"前端分享","description":"学习总结 思考感悟","author":"chenghao","url":"https://yezihaohao.github.io"},"pages":[{"title":"Hello World","date":"un44fin44","updated":"un44fin44","comments":true,"path":"hello-world.html","permalink":"https://yezihaohao.github.io/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"tags","date":"un44fin44","updated":"un44fin44","comments":true,"path":"tags/index.html","permalink":"https://yezihaohao.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"un44fin44","updated":"un44fin44","comments":true,"path":"categories/index.html","permalink":"https://yezihaohao.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"un44fin44","updated":"un44fin44","comments":false,"path":"about/index.html","permalink":"https://yezihaohao.github.io/about/index.html","excerpt":"","text":"关于测试呵呵我只是想安静地写前端"},{"title":"imgs","date":"un66fin66","updated":"un66fin66","comments":true,"path":"imgs/index.html","permalink":"https://yezihaohao.github.io/imgs/index.html","excerpt":"","text":""}],"posts":[{"title":"Socket.io+Notification实现浏览器消息推送","slug":"Socket-io-Notification实现浏览器消息推送","date":"un11fin11","updated":"un22fin22","comments":true,"path":"2017/02/20/Socket-io-Notification实现浏览器消息推送/","link":"","permalink":"https://yezihaohao.github.io/2017/02/20/Socket-io-Notification实现浏览器消息推送/","excerpt":"","text":"前言 socket.io: 包含对websocket的封装，可实现服务端和客户端之前的通信。详情见官网 (虽然是英文文档，但还是通俗易懂)。 Notification: Html5新特性，用于浏览器的桌面通知，只有部分浏览器支持。 通过nodejs+Socket.io+Notification实现服务端往浏览器客户端发送自定义消息。 若有问题可加群264591039与我讨论。 转载请注明出处！ 开发前提本地安装nodejs以及npm对nodejs以及express框架有一定了解。（本篇将和官方文档一样，采用express 4.10.2） 环境搭建 新建一个文件夹notification（以下操作都在该文件夹的根目录进行） npm初始化package.json文件 npm init 安装express(指定版本4.10.2，没有试过其他版本，感兴趣可以试下) npm install --save express@4.10.2 安装socket.io(本人安装的版本是1.7.3) npm install --save socket.io 编写代码构建通信环境在根目录下新建一个index.html（注：index页面的样式来自socket.io的官方示例）12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Socket.IO Notification&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font: 13px Helvetica, Arial; &#125; form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125; form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125; #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125; #messages li &#123; padding: 5px 10px; &#125; #messages li:nth-child(odd) &#123; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;messages&quot;&gt;&lt;/ul&gt; &lt;form action=&quot;&quot;&gt; &lt;input id=&quot;m&quot; autocomplete=&quot;off&quot; /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 新建一个index.js文件，并在js文件中构建相应的对象和变量，创建监听端口为8080 的服务器，以及添加映射到index.html的路由。12345678910111213let express = require('express'), app = express(), http = require('http').Server(app), io = require('socket.io')(http);app.use(express.static(__dirname + '/public'));app.get('/', function(req, res)&#123; res.sendfile('index.html');&#125;);http.listen(8080, function()&#123; console.log('listening on port 8080');&#125;); 运行 node index.js 用浏览器打开http://localhost:8080 成功的话即可看到index.html页面的内容。在index.js的监听端口代码上方添加socket.io的监听事件，监听用户连接的connection。123io.on('connection', function(socket)&#123; console.log('a user connected');&#125;); 创建监听Event事件:notification，并用emit向客户端推送消息1234567io.on('connection', function(socket)&#123; console.log('a user connected'); socket.on('notification', function(msg)&#123; console.log(msg); io.emit('notification', msg); &#125;);&#125;); 在index.html页面中的上方引入socket.io文件，并用emit向服务器提交数据以及监听事件notification，接收服务器推送的消息注意，引入socket.io的方式在运行node index.js之后才有效果，直接打开index.html是找不到这个文件的12345678910111213 &lt;script type=\"text/javascript\" src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt;let socket = io();$('form').submit(function()&#123; socket.emit('notification', $('#m').val()); $('#m').val(''); return false;&#125;);socket.on('notification', function(msg)&#123; console.log(msg);&#125;); &lt;/script&gt; 浏览器打开http://localhost:8080 后，在input框中输入，点击发送，在nodejs运行的控制台可以看到如下信息：1234a user connected //以下数据是输入框输入的数据hello test测试 实现自定义消息推送完整代码：12345678910111213141516171819202122232425 &lt;script&gt;let socket = io();$('form').submit(function()&#123; socket.emit('notification', $('#m').val()); $('#m').val(''); return false;&#125;);socket.on('notification', function(msg)&#123; notice(msg); //若允许通知，待输入消息后监听变化就会调用通知方法&#125;); Notification.requestPermission(function(permission) &#123;&#125;); //询问浏览器是否允许通知 function notice(msg) &#123; let _notification = new Notification(`消息通知`,&#123; body:`$&#123;msg&#125;`, icon:'http://localhost:8080/23539868.jpg' &#125;); setTimeout(function()&#123; _notification.close(); //设置5秒后自动关闭通知框 &#125;,5000); &#125; &lt;/script&gt; 运行截图完整示例代码见GitHub","categories":[{"name":"消息推送","slug":"消息推送","permalink":"https://yezihaohao.github.io/categories/消息推送/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://yezihaohao.github.io/tags/Nodejs/"},{"name":"Socket.io","slug":"Socket-io","permalink":"https://yezihaohao.github.io/tags/Socket-io/"}]},{"title":"Vuejs2.X组件化-阿里的G2图表组件","slug":"Vuejs2-X组件化-阿里的G2图表组件","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2017/02/14/Vuejs2-X组件化-阿里的G2图表组件/","link":"","permalink":"https://yezihaohao.github.io/2017/02/14/Vuejs2-X组件化-阿里的G2图表组件/","excerpt":"前言 vue 的组件化开发是一个非常不错的机制.’一处开发,多处引用’，不仅降低的维护成本，提高了开发效率，而且单独的组件有单独的视图和交互数据逻辑，使得系统层次更加分明。若有问题可加群264591039与我讨论~转载文章请标明出处！ 开发场景数据可视化是我们互联网常见的功能，所以难免我们会在项目中插入图表等，找到一个还算可以的图形插件，阿里的G2图形库，详情请参见G2官网。接下来就开始我们的Vue G2组件化之旅。 脚手架搭建helloworld先用脚手架工具 vue-cli搭建一个vue的helloworld项目(Vue的相关教程请看Vue官网)，按照readme文档正常运行该项目。 安装G2插件在package.json的目录下用npm包管理工具安装G2插件库1npm install --save-dev g2 我用到的版本是2.2.1，现在最新的好像是2.2.2，应该也没什么问题，不过我没测试过 新建G2Line.vue单文件组件在components目录下新建G2Line.vue文件（当前是以线形图为例的组件）。在template标签中新增标签1234&lt;template&gt; &lt;!--此处的id用变量，方便同一页面引用多次相同的组件--&gt; &lt;div :id=\"id\"&gt;&lt;/div&gt;&lt;/template&gt;","text":"前言 vue 的组件化开发是一个非常不错的机制.’一处开发,多处引用’，不仅降低的维护成本，提高了开发效率，而且单独的组件有单独的视图和交互数据逻辑，使得系统层次更加分明。若有问题可加群264591039与我讨论~转载文章请标明出处！ 开发场景数据可视化是我们互联网常见的功能，所以难免我们会在项目中插入图表等，找到一个还算可以的图形插件，阿里的G2图形库，详情请参见G2官网。接下来就开始我们的Vue G2组件化之旅。 脚手架搭建helloworld先用脚手架工具 vue-cli搭建一个vue的helloworld项目(Vue的相关教程请看Vue官网)，按照readme文档正常运行该项目。 安装G2插件在package.json的目录下用npm包管理工具安装G2插件库1npm install --save-dev g2 我用到的版本是2.2.1，现在最新的好像是2.2.2，应该也没什么问题，不过我没测试过 新建G2Line.vue单文件组件在components目录下新建G2Line.vue文件（当前是以线形图为例的组件）。在template标签中新增标签1234&lt;template&gt; &lt;!--此处的id用变量，方便同一页面引用多次相同的组件--&gt; &lt;div :id=\"id\"&gt;&lt;/div&gt;&lt;/template&gt; 在script标签中引入G2并开始先关操作代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import G2 from 'g2'; export default &#123; data () &#123; return &#123; chart: null &#125;; &#125;, props: &#123; charData: &#123; type: Array, default: function () &#123; return &#123; data: [&#123;'mzkId': 112, 'strftime': \"2017-01-11\", 'value': 9275501&#125;, // 测试数据，根据自己需求自己设置数据 &#123;'mzkId': 112, 'strftime': \"2017-01-12\", 'value': 9281904&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-13\", 'value': 9290777&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-14\", 'value': 9297913&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-15\", 'value': 9306918&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-16\", 'value': 9315641&#125;] &#125;; &#125; &#125;, id: String &#125;, mounted: function () &#123;// this.drawChart(); // 第一步想到的是创建的时候更新图表，但是这个不适用于异步请求接口获取相关数据，所以采用下面的监听的方式 &#125;, beforeUpdate: function () &#123;// this.drawChart(); &#125;, watch: &#123; charData: function (val, oldVal) &#123; // 监听charData，当放生变化时，触发这个回调函数绘制图表 console.log('new: %s, old: %s', val, oldVal); this.drawChart(val); &#125; &#125;, methods: &#123; drawChart: function (datas) &#123; // 如果图形存在则删除再创建，这个地方感觉稍微有点坑 // 具体的G2 api函数说明请看上面提供的官网地址，此处不再逐一说明 this.chart &amp;&amp; this.chart.destroy(); let data = datas; this.chart = new G2.Chart(&#123; id: this.id, width: 1000, height: 250 &#125;); this.chart.source(data, &#123; strftime: &#123; alias: '日期', type: 'cat', range: [0, 1] &#125;, value: &#123; alias: '数量值(人)' &#125; &#125;); this.chart.line().position('strftime*value').size(2); this.chart.point().position('strftime*value').color('#757373') .shape('circle') .label('value', &#123;offset: 20, label: &#123;fill: '#000'&#125;&#125;); this.chart.animate(false); this.chart.render(); &#125; &#125; &#125; App.vue引入组件并渲染图表在app.vue中引入上一步新建的G2Line.vue组件，并加载到当前vue实例中1234567891011121314151617&lt;script&gt; import G2Line from './components/G2Line.vue'; export default &#123; components: &#123; G2Line &#125;, data () &#123; return &#123; serverData: [] &#125; &#125;, methods: &#123; // 此处省略从服务器获取数据并且赋值给this.serverData // 推荐使用axios请求接口 &#125; &#125;&lt;/script&gt; 获取服务端数据之后，在template中创建组件标签，并将serverData发送给子组件G2Line12&lt;!--同步设置id传送给子组件--&gt;&lt;g2-line :charData=\"serverData\" :id=\"'c1'\" id=\"c1\"&gt;&lt;/g2-line&gt; 刷新界面，成功看到页面图表的渲染","categories":[],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"https://yezihaohao.github.io/tags/Vuejs/"}]},{"title":"Nodejs爬虫--抓取豆瓣电影网页数据（下）","slug":"Nodejs爬虫-抓取豆瓣电影网页数据（下）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2017/02/11/Nodejs爬虫-抓取豆瓣电影网页数据（下）/","link":"","permalink":"https://yezihaohao.github.io/2017/02/11/Nodejs爬虫-抓取豆瓣电影网页数据（下）/","excerpt":"接着上篇 Nodejs爬虫–抓取豆瓣电影网页数据（上） 本篇主要描述将上次抓取的数据存入mongodb数据库 前提：百度或谷歌mongodb的安装教程，安装本地并成功运行 推荐一款mongodb数据库可视化管理工具：Robomongo。可以加群264591039获取安装包或自行寻找资源 首先用npm安装第三方数据库操作包：mongoose.关于mongoose详情请查看官方文档1npm install --save-dev mongoose 引入mongoose包开始对mongodb进行管理当前目录下新建一个mongo.js文件方便管理，在该文件中引入相关包：12let mongoose = require('mongoose'), assert = require('assert');","text":"接着上篇 Nodejs爬虫–抓取豆瓣电影网页数据（上） 本篇主要描述将上次抓取的数据存入mongodb数据库 前提：百度或谷歌mongodb的安装教程，安装本地并成功运行 推荐一款mongodb数据库可视化管理工具：Robomongo。可以加群264591039获取安装包或自行寻找资源 首先用npm安装第三方数据库操作包：mongoose.关于mongoose详情请查看官方文档1npm install --save-dev mongoose 引入mongoose包开始对mongodb进行管理当前目录下新建一个mongo.js文件方便管理，在该文件中引入相关包：12let mongoose = require('mongoose'), assert = require('assert'); 获取表构造器Schema并映射mongodb相应的collection12345678910111213let Schema = mongoose.Schema;let filmSchema = new Schema(&#123; //自定义相应的表数据字段 title: String, type: String, directories: String, scriptwriter: String, actors: String &#125;);//映射collection并生成model对象用于管理数据表的增删改查//默认是映射到名为films的collection//若自定义表明则：let filmSchema = new Schema(&#123;..&#125;, &#123; collection: 'data' &#125;); 'data'即为自定义名称let Film = mongoose.model('Film', filmSchema); 连接mongodb数据库并exports Film对象123456789let db = mongoose.connect('mongodb://127.0.0.1:27017/spider');db.connection.on('error', (err) =&gt; &#123; console.log(`数据库连接失败：$&#123;err&#125;`);&#125;);db.connection.on('open', () =&gt; &#123; console.log('数据库连接成功');&#125;);module.exports = &#123;Film: Film&#125;; 在spider.js中引入Film对象并添加入库操作代码123456789101112131415161718let mongo = require('./mongo');//在请求网页的end函数中添加入库操作xxxx.end((err, res) =&gt; &#123; var $ = cheerio.load(res.text); //用cheerio获取整个页面DOM对象 var _data = &#123;title:'', type: '', directories: '', scriptwriter: '', actors: ''&#125;; _data.title = $('#content h1 span').text(); _data.directories = $('#info .attrs').eq(0).text(); _data.scriptwriter = $('#info .attrs').eq(1).text(); _data.actors = $('#info .attrs').eq(2).text(); $('span[property=\"v:genre\"]').each(function (index) &#123; _data.type += ($(this).text() + (index == $('span[property=\"v:genre\"]').length - 1 ? '' : '、')); &#125;); console.log(_data); mongo.Film.create(_data, (err, doc) =&gt; &#123; assert.equal(err, null); console.log(doc); &#125;);&#125;); 运行spider.js，并查看数据库中的数据12node spider.js//用上述提到的可视化工具查看数据库是否成功有数据入库","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yezihaohao.github.io/categories/爬虫/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yezihaohao.github.io/tags/Javascript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://yezihaohao.github.io/tags/Nodejs/"}]},{"title":"Javascript正则表达式整合","slug":"Javascript正则表达式整合","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2017/02/10/Javascript正则表达式整合/","link":"","permalink":"https://yezihaohao.github.io/2017/02/10/Javascript正则表达式整合/","excerpt":"项目中常用正则表达式使用整合大全提取网页标签内容一.单个标签提取123let str = `&lt;a class=\"menu\"&gt;GitHub&lt;/a&gt;`;let content = str.match(/&lt;a class=\"menu\"&gt;([\\s\\S]+)&lt;\\/a&gt;/)[1];","text":"项目中常用正则表达式使用整合大全提取网页标签内容一.单个标签提取123let str = `&lt;a class=\"menu\"&gt;GitHub&lt;/a&gt;`;let content = str.match(/&lt;a class=\"menu\"&gt;([\\s\\S]+)&lt;\\/a&gt;/)[1]; 不定时更新中…","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://yezihaohao.github.io/categories/正则表达式/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yezihaohao.github.io/tags/Javascript/"}]},{"title":"Nodejs爬虫--抓取豆瓣电影网页数据（上）","slug":"Nodejs爬虫-抓取豆瓣电影网页数据（上）","date":"un44fin44","updated":"un66fin66","comments":true,"path":"2017/02/09/Nodejs爬虫-抓取豆瓣电影网页数据（上）/","link":"","permalink":"https://yezihaohao.github.io/2017/02/09/Nodejs爬虫-抓取豆瓣电影网页数据（上）/","excerpt":"之前写了一个nodejs的开源爬虫小项目，补上博客详细解析下代码。 PS：共有上下两篇，第一篇讲从网站上抓取数据，第二篇讲将抓取的数据存入mongodb数据库。 我们快速开始吧首先，安装nodejs，然后用npm工具初始化资源管理配置文件：package.json新建spider文件夹，在该文件夹下面初始化package.json1npm init 然后用npm安装相关库文件：1npm install --save-dev superagent cheerio eventproxy async 在文件夹下面新建spider.js, 在文件中引入需要用到的nodejs模块如下(具体用法请查询网上相关资料)：12345let superagent = require('superagent'), //nodejs里面一个非常方便的客户端代理请求模块，支持get,post,put,delete等 cheerio = require('cheerio'), //类似于jQuery的DOM操作模块，可以提取html中想要的信息 eventproxy = require('eventproxy'), //控制异步请求并发，可以监听请求，使得某些请求完毕之后在发送请求 assert = require('assert'), //异常抛出判断模块，assert.equal(err, null); 如果err不为null,则直接抛出异常 async = require('async'); //控制请求并发连接数","text":"之前写了一个nodejs的开源爬虫小项目，补上博客详细解析下代码。 PS：共有上下两篇，第一篇讲从网站上抓取数据，第二篇讲将抓取的数据存入mongodb数据库。 我们快速开始吧首先，安装nodejs，然后用npm工具初始化资源管理配置文件：package.json新建spider文件夹，在该文件夹下面初始化package.json1npm init 然后用npm安装相关库文件：1npm install --save-dev superagent cheerio eventproxy async 在文件夹下面新建spider.js, 在文件中引入需要用到的nodejs模块如下(具体用法请查询网上相关资料)：12345let superagent = require('superagent'), //nodejs里面一个非常方便的客户端代理请求模块，支持get,post,put,delete等 cheerio = require('cheerio'), //类似于jQuery的DOM操作模块，可以提取html中想要的信息 eventproxy = require('eventproxy'), //控制异步请求并发，可以监听请求，使得某些请求完毕之后在发送请求 assert = require('assert'), //异常抛出判断模块，assert.equal(err, null); 如果err不为null,则直接抛出异常 async = require('async'); //控制请求并发连接数 用superagent请求豆瓣的某个接口，并把所有的页面链接放到一个数组里面，用eventproxy控制监听该请求结束之后才开始请求相应的详情页面。12345678superagent.get(URL) .end((err, res) =&gt; &#123; let _pageUrls = []; res.body.forEach((val) =&gt; &#123; _pageUrls.push(val.url); &#125;); ep.emit('pageUrls', _pageUrls); //监听相关实例，完成之后告诉pageUrls &#125;) 监听事件完成之后，执行请求相应的豆瓣电影详情页面.并用async控制请求的并发量，可以降低请求的频率和速度123456789101112131415161718192021222324252627let ep = eventproxy.create('pageUrls', (pageUrls) =&gt; &#123; //创建一个监听实例 let _http = (url, callback) =&gt; &#123; let _delay = parseInt((Math.random() * 30000000) % 1000, 10); //随机延时请求 superagent.get(url) .end((err, res) =&gt; &#123; var $ = cheerio.load(res.text); //用cheerio获取整个页面DOM对象 var _data = &#123;title:'', type: '', directories: '', scriptwriter: '', actors: ''&#125;; _data.title = $('#content h1 span').text(); _data.directories = $('#info .attrs').eq(0).text(); _data.scriptwriter = $('#info .attrs').eq(1).text(); _data.actors = $('#info .attrs').eq(2).text(); $('span[property=\"v:genre\"]').each(function (index) &#123; _data.type += ($(this).text() + (index == $('span[property=\"v:genre\"]').length - 1 ? '' : '、')); &#125;); console.log(_data); &#125;); setTimeout(() =&gt; &#123; callback(null, url); &#125;, _delay); &#125;; async.mapLimit(pageUrls, 3, (url, callback) =&gt; &#123; //用async 的 mapLimit(arr, limit, iterator, callback) 接口控制请求并发量为3 _http(url, callback); &#125;, (err, res) =&gt; &#123; assert.equal(err, null); &#125;)&#125;); 本章节结束，未完待续…下期是怎么将抓取的数据存入mongodb数据库！","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yezihaohao.github.io/categories/爬虫/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yezihaohao.github.io/tags/Javascript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://yezihaohao.github.io/tags/Nodejs/"}]}]}